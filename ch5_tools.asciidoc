[[productivity_tools]]
== Selected Productivity Tools for Enterprise Developers

The toolbox of an enterprise HTML5 developer contains tools that can improve productivity. In this chapter, we share with you some of the tools that we use.

We'll start this chapter with a brief introduction of Node.js (or simply Node)--the server-side JavaScript framework and Node Package Manager (npm). Node and npm serve as a foundation for the tools covered in this chapter.

Next, we'll highlight a handful of productivity tools that we use in our consulting projects, namely:

Grunt::
    A task-runner framework for JavaScript projects that allows you to automate repetitive operations such as running tests.

Bower::
    A package manager for web projects that helps in maintaining application dependencies. 

Yeoman::
    A collection of code-generation tools and best practices. 


In addition to these tools that can be used with various JavaScript frameworks, we'll introduce you to Clear Toolkit for Ext JS, which includes the code generator Clear Data Builder--this tool was created and open-sourced by our company, Farata Systems. With Clear Toolkit, you'll be able to quickly start a project that utilizes the Ext JS framework for front-end development and Java on the server side.

=== Using Node.js, V8, and npm

_Node.js_ is a server-side JavaScript framework. Node uses _V8_, the JavaScript engine by Google (Chrome/Chromium also use it). Node provides the JavaScript API for accessing the filesystem, sockets, and running processes, which makes it great for general-purpose scripting runtime. You can find more information about Node at http://nodejs.org/about/[its website].(((productivity tools, Node.js)))(((Node.js)))(((V8 JavaScript engine)))(((JavaScript, V8 engine for)))(((npm utility)))(((dependency management, npm utility)))

Many tools are built on top of Node JavaScript APIs. The http://gruntjs.com/[Grunt] tool is one of them. We will use Grunt later in this book to automate execution of repetitive development tasks.

npm is a utility that comes bundled with Node. npm provides a unified API and metadata model for managing dependencies in JavaScript projects. A `package.json` file is the project's dependencies descriptor. npm installs project dependencies using information from `package.json`. npm uses a https://npmjs.org/[community repository] for open-source JavaScript projects to resolve dependencies. npm can also use private repositories.

Node and npm are cross-platform software and binaries available for Windows, Linux, and OS X operating systems. 

To use this book's code samples, you need to download and install Node from http://nodejs.org/download/[its website].

=== Automating Everything with Grunt

You should automate every aspect of the development workflow to reduce the cost of building, deploying, and maintaining your application. In this section, we introduce http://gruntjs.com/[Grunt]--a task runner framework for JavaScript projects that can help you automate repetitive operations such as running tests when the code changes. You can follow http://gruntjs.com/getting-started[the instructions from Grunt's  website] to install it on your machine.(((productivity tools, Grunt, workflow automation with)))((("workflow automation", see="productivity tools")))((("build automation", see="productivity tools")))(((Grunt, workflow automation with)))

Grunt can watch your code changes and automate the process of running tests when the code changes. Tests should help in assessing the quality of our code.

With the Grunt tool, you can have a script to run all your tests. If you come from the Java world, you know about Apache Ant, a general-purpose command-line tool to drive processes that describe _build files_ as _targets_ in the _build.xml_ file. Grunt also runs the tasks described in scripts. A wide range of tasks are available today--starting with running automated unit tests and ending with JavaScript code minification. Grunt provides a separate layer of abstraction on which you can define tasks in a special domain-specific language (DSL) in a Gruntfile for execution.

=== Exploring the Simplest Grunt File

Let's start with the simplest Grunt project setup, shown in <<simple_gruntfile>>.(((productivity tools, Grunt, file setup)))(((Grunt, file setup))) The following two files must be present in the project directory:

_package.json_::
    This file is used by npm to store metadata and project dependencies. 
+
List Grunt and its plug-ins that your project needs as _devDependencies_ in this file.

_Gruntfile_::
    This file is named _Gruntfile.js_ or _Gruntfile.coffee_; it is used to configure or define the tasks and load Grunt plug-ins.

[[simple_gruntfile]]
.The simplest possible Gruntfile
====
[source,javascript]
----------------------------------------------------------------------
module.exports = function (grunt) {
    'use strict';

    grunt.registerTask('hello', 'say hello', function(){    // <1>
        grunt.log.writeln('Hello from grunt');              // <2>
    });

    grunt.registerTask('default', 'hello');                 // <3>              
};
----------------------------------------------------------------------
====


<1> Register a new task named `hello`.

<2> Print the greeting text by using http://gruntjs.com/api/grunt.log[grunt's log API].

<3> With `grunt.registerTask`, we define a default task to run when Grunt is called without any parameters. 

Each task can be called separately from the command line by passing the task's name as a command-line parameter. For example, `grunt hello` would execute only the task named +hello+ from the preceding script.

Let's run this `hello` task with the following command:

+grunt --gruntfile Grunt_simple.js hello+.

[source,bash]
----------------------------------------------------------------------
Running "hello" task
Hello from grunt

Done, without errors.
----------------------------------------------------------------------

=== Using Grunt to Run JSHint Checks

Now that we've covered the basics of Grunt tool, we can use it for something more interesting than just printing _hello world_ on the screen. Because JavaScript is an interpreted language, there is no compiler to help catch syntax errors. But you can use http://www.jshint.com/[JSHint], an open-source tool, which helps identify errors in JavaScript code in lieu of a compiler. Consider the JavaScript code in <<LISTING_WITH_ERRORS>>.(((productivity tools, Grunt, JSHint checks)))(((syntax errors)))(((debugging, syntax errors)))(((JSHint)))(((Grunt, JSHint checks)))

[[LISTING_WITH_ERRORS]]
.A JavaScript array with a couple typos
====
[source,javascript]
----
var bonds = [                   // <1>
            'Sean Connery',
            'George Lazenby',
            'Roger Moore',
            'Timothy Dalton',
            'Pierce Brosnan',
            'Daniel Craig',     // <2>
            //'Unknow yet actor' 
        ]                       // <3>
----
====


<1> We want to define an array that contains names of actors who played James Bond in the canonical series.

<2> Here is an example of a typo that may cause errors in some browsers. A developer commented-out the line containing an array element but kept the comma in the previous line.

<3> A missing semicolon is a typical typo. Although it is not an error (and many JavaScript developers do consider omitting semicolons a best practice), an automatic semicolon insertion (ASI) will get you covered in this case.

.What Is an Automatic Semicolon Insertion?
****
In JavaScript, semicolons are optional, which means that you can omit a semicolon between two statements written on separate lines. Automatic semicolon insertion is a source code parsing procedure that infers omitted semicolons in certain contexts into your program. You can read more about optional semicolons in _JavaScript: The Definitive Guide_ by David Flanagan (O'Reilly).(((JavaScript, optional semicolons)))(((semicolons)))
****

The preceding code snippet is a fairly simple example that can cause trouble and frustration if you don't have proper tools to check the code semantics and syntax. Let's see how JSHint can help in this situation. 

JSHint can be installed via npm with the command `npm install jshint -g`. Now you can run JSHint against our code snippet:

[source,bash]
----
> jshint jshint_example.js
jshint_example.js: line 7, col 27, Extra comma. (it breaks older versions of IE)
jshint_example.js: line 9, col 10, Missing semicolon. # <1>

2 errors            # <2>
----

<1> JSHint reports the location of the error and a short description of the problem.

<2> The total count of errors 

TIP: The WebStorm IDE has http://blogs.jetbrains.com/idea/2012/05/lint-your-javascript-with-jslintjshint-in-real-time/[built-in support] for the JSHint tool. There is a third-party plugiin for Eclipse: http://github.eclipsesource.com/jshint-eclipse/[jshint-eclipse].

Grunt also has a task to run JSHint against your JavaScript code base. <<grunt_file_with_jshint>> shows what a JSHint configuration in Grunt looks like.

[[grunt_file_with_jshint]]
.A grunt file with JSHint support
====
[source,javascript]
----
module.exports = function(grunt) {
  grunt.initConfig({
    jshint: {
      gruntfile: {          // <1>
        src: ['Gruntfile_jshint.js']
      },
      app: {
        src: ['app/js/app.js']
      }
    }
  });

  grunt.loadNpmTasks('grunt-contrib-jshint');       
  grunt.registerTask('default', ['jshint']);        // <2>
};
----
====


<1> Because Gruntfile is a JavaScript file, JSHint can check it as well and identify the errors.

<2> The https://github.com/gruntjs/grunt-contrib-jshint[grunt-contrib-jshint] has to be installed. When +grunt+ is run without any parameters, the default task `jshint` is triggered.

[source,bash]
----
> grunt 

Running "jshint:gruntfile" (jshint) task
>> 1 file lint free.

Running "jshint:app" (jshint) task
>> 1 file lint free.

Done, without errors.
----

=== Watching for the File Changes

Another handy task to use in a developer's environment is the `watch` task. The purpose of this task is to monitor files in preconfigured locations.(((productivity tools, Grunt, watch task)))(((watch task)))(((files, watching for changes in)))(((Grunt, watch task))) When the watcher detects any changes in those files, it will run the configured task. <<LIST_WATCH_TASK>> shows what a <<LIST_WATCH_TASK,watch task config>> looks like:

[[LIST_WATCH_TASK]]
.A `watch` task config 
====
[source,javascript]
----
module.exports = function(grunt) {
    grunt.initConfig({
        jshint: {
            // ... configuration code is omitted 
        },
        watch: {        // <1>
            reload: {
                files: ['app/*.html', 'app/data/**/*.json', 'app/assets/css/*.css', 
                  'app/js/**/*.js', 'test/test/tests.js', 'test/spec/*.js'], // <2>
                tasks: ['jshint']           // <3>
            }
        }
    });
    grunt.loadNpmTasks('grunt-contrib-jshint');  // <4>
    grunt.loadNpmTasks('grunt-contrib-watch');
    grunt.registerTask('default', ['jshint']);
};
----
====


<1> The `watch` task configuration starts here.

<2> The list of the files that need to be monitored for changes.

<3> An array of tasks to be triggered after a file change event occurs.

<4> The https://github.com/gruntjs/grunt-contrib-watch[grunt-contrib-watch plugin ] has to be installed. 

You can run +grunt watch+ from the command line (keep in mind that it never ends on its own). 

[source,bash]
----
> grunt watch

Running "watch" task
Waiting...OK
>> File "app/js/Player.js" changed.
Running "jshint:gruntfile" (jshint) task
>> 1 file lint free.

Running "jshint:app" (jshint) task
>> 1 file lint free.

Done, without errors.

Completed in 0.50s at Tue May 07 2013 00:41:42 GMT-0400 (EDT) - Waiting...
----

TIP: The article http://yeoman.io/blog/performance-optimization.html[Grunt and Gulp Tasks for Performance  Optimization] lists various useful Grunt tasks for optimizing loading of images and CSS.

=== Using Bower

https://github.com/bower/bower[Bower] is a package manager for web projects. Twitter has donated it to the open-source community. Bower is a utility and a community-driven repository of libraries that help download third-party software required for application code that will run in a web browser. The Bower's purpose is similar to npm, but the latter is more suitable for server-side projects.(((productivity tools, Bower package manager)))(((dependency management, Bower package manager)))

Bower can take care of transitive (dependency of a dependency) dependencies and download all required library components. Each Bower's package has a _bower.json_ file, which contains the package metadata for managing the package's transitive dependencies. Also, _bower.json_ can contain information about the package repository, readme file, license, and so forth. You can find _bower.json_ in the root directory of the package. For example, _components/requirejs/bower.json_ is a path for the RequireJS metadata file. Bower can be installed via npm. The following line shows how to install Bower globally in your system.

[source,bash]
----
npm install -g bower    
----

TIP: Java developers use package managers like Gradle or Maven that have functionality similar to Bower's.

Let's begin using Bower now. For example, here is a Bower command to install the library RequireJS.

[source,bash]
----
bower install requirejs --save 
----
Bower installs RequireJS into the _components/requirejs_ directory and saves information about dependencies in the _bower.json_ configuration file.

Bower simplifies the delivery of dependencies into a target platform, which means that you don't need to store dependencies of your application in the source control system. Just keep your application code there and let Bower bring all other dependencies described in its configuration file. 

TIP: There are pros and cons for storing dependencies in the source control repositories. Read the http://addyosmani.com/blog/checking-in-front-end-dependencies/[article by Addi Osmani] that covers this subject in more detail.

Your application will have its own _bower.json_ file with the list of the dependencies (see <<application_components>>). At this point, Bower can install all required application dependencies with one command, `bower install`, which will deliver all your dependency files into the +components+ directory. Here is the content of _bower.json_ for our Save The Child application: 

[source,javascript]
----
{
  "name": "ch7_dynamic_modules",
  "description": "Chapter 7: Save The Child, Dynamic Modules app",
  "dependencies": {
    "requirejs": "~2.1.5",
    "jquery": ">= 1.8.0",
    "qunit": "~1.11.0",
    "modernizr": "~2.6.2",
    "requirejs-google-maps": "latest"
  }
}
----

Application dependencies are specified in the corresponding +dependencies+ section. The +>=+ sign indicates that the corresponding software cannot be older than the specified version.

[[application_components]]
.Directory structure of application's components
image::images/ewdv_0501.png[scale="50"]

Also, there is a http://sindresorhus.com/bower-components/[Bower search tool] to find the desired component in its repository.

=== Using Yeoman 

http://yeoman.io/[Yeoman] is a collection of tools and best practices that help bootstrap a new web project. Yeoman consists of three main parts: Grunt, Bower, and Yo. Grunt and Bower were explained earlier in this chapter.(((productivity tools, Yeoman tool collection)))(((Yoeman tool collection)))(((code-generation tools)))(((generators))) 

Yo is a code-generation tool. It makes the start of the project faster by scaffolding a new JavaScript application. Yo can be installed via npm similar to the other tools. The following command shows how to install Yo globally in your system; if you didn't have Grunt and Bower installed before, this command will install them automatically.

[source,bash]
----
npm install -g yo    
----

For code generation, Yo relies on plug-ins called _generators_. A generator is a set of instructions to Yo and file templates. You can use the http://yeoman.io/community-generators.html[Yeoman Generators search tool] (see <<yo_serach>>) to discover community-developed generators. At the time of this writing, you can use one of about 430 community-developed generators to scaffold your project.

For example, let's scaffold the Getting Started project for RequreJS. RequireJS is a framework that helps dice code of your JavaScript application into modules. We cover this framework in detail in <<modularizing_javascript_projects>>.

[[yo_serach]]
.Yeoman Generators search tool
image::images/ewdv_0502.png[align="center"]

The search tool found a bunch of generators that have the keyword +requirejs+ in their name or description. We're looking for a generator that "requirejs" (<<yo_serach,highlighted>> with a red square). When we click the name link, the https://github.com/danheberden/yeoman-generator-requirejs[GitHub page of RequireJS generator] displays. Usually, the generator developers provide a reference of the generator's available tasks.

Next we need to install the generator on our local machine by using the following command:

----
npm install -g generator-requirejs
----

After installation, we can start the _yo_ command and as a parameter, we need to specify the generator's name. 
To start scaffolding a RequireJS application, we can use the following command:

----
yo requirejs
----

We need to provide answers to the wizard's questions. A sample dialog with Yeoman is shown in <<yeoman_prompt>>.

[[yeoman_prompt]]
.Yeoman prompt
====
----
     _-----_
    |       |
    |--(o)--|   .--------------------------.
   `---------´  |    Welcome to Yeoman,    |
    ( _´U`_ )   |   ladies and gentlemen!  |
    /___A___\   '__________________________'
     |  ~  |
   __'.___.'__
 ´   `  |° ´ Y `

This comes with requirejs, jquery, and grunt all ready to go
[?] What is the name of your app? requirejs yo
[?] Description: description of app for package.json
   create Gruntfile.js
   create package.json
   create bower.json
   create .gitignore
   create .jshintrc
   create .editorconfig
   create CONTRIBUTING.md
   create README.md
   create app/.jshintrc
   create app/config.js
   create app/main.js
   create test/.jshintrc
   create test/index.html
   create test/tests.js
   create index.htm

I'm all done. Running bower install & npm install for you to install the required 
dependencies. If this fails, try running the command yourself.

.... npm install output is omitted
----
====


You will get all directories and files set up, and you can start writing your code immediately. The structure of your project will reflect common best practices from the JavaScript community (see <<yo_dir_tree>>).

[[yo_dir_tree]]
.Scaffolded RequireJS application directory structure
image::images/ewdv_0503.png[scale="40"]

After executing the _yo_ command, you will get Grunt set up with following configured tasks:

+clean+::
    Cleans files and folders. 
+concat+::
    Concatenates files. 
+uglify+::
    Minifies files with UglifyJS.
+qunit+::
    Runs QUnit unit tests in a headless PhantomJS instance.
+jshint+::
    Validates files with JSHint.
+watch+::
    Runs predefined tasks whenever watched files change.
+requirejs+::
    Builds a RequireJS project.
+connect+::
    Starts a connect web server.
+default+::
    An alias for +jshint+, +qunit+, +clean+, +requirejs+, +concat+, +uglify+ tasks.
+preview+::
    An alias for +connect:development+ tasks.
+preview-live+::
    An alias for +default+, +connect:production+ tasks.

Yeoman also has a https://github.com/yeoman/generator-generator[generator for generator scaffolding]. It might be very useful if you want to introduce your own workflow for a web project.

The next code generator that we'll cover is a more specific one. It can generate the entire ExtJS-Java application.

=== Using Ext JS and CDB for Productive Enterprise Web Development 

The authors of this book work for a company called Farata Systems, which has developed the open-source, freely available software called Clear Toolkit for Ext JS, and the code generator and Eclipse IDE plug-in Clear Data Builder (CDB) comes with it. CDB is a productivity tool that was created specifically for enterprise applications that use Java on the server side and need to retrieve, manipulate, and save data in persistent storage.(((Farata Systems)))((("Clear Toolkit for Ext JS")))(((Ext JS, Clear Toolkit for)))((("Clear Data Builder (CDB)", "creation of")))((("productivity tools", "Clear Data Builder (CDB)", "creation of")))(((CRUD applications, jumpstarting development of))) 

Such enterprise applications are known as _CRUD applications_ because they perform create, retrieve, update, and delete operations with data. If the server side of your web application is developed in Java, with CDB you can easily generate a CRUD application, wherein the Ext JS front end communicates with the Java back end. In this section, you'll learn how to jump-start development of such CRUD web applications. 

NOTE: Familiarity with core Java concepts such as classes, constructors, getters and setters, and annotations is required for understanding the materials of this section.

The phrase _to be more productive_ means to write less code while producing faster results faster. This is what CDB is for, and you'll see it helps you integrate the client side with the back end by using the remote procedure call (RPC) style and how to implement data pagination for your application. To be more productive, you need to have the proper tools installed. We'll cover this next.((("Clear Data Builder (CDB)", "increasing productivity with")))((("productivity tools", "Clear Data Builder (CDB)", "increasing productivity with")))

==== Ext JS MVC Application Scaffolding 

This section covers the following topics:

- Using Clear Toolkit for Ext JS 
- Creating an Ext JS MVC front end for a Java-based project
- Deploying and running your first Ext JS and Java application on an Apache Tomcat server

Clear Toolkit for Ext JS includes the following:

Clear Data Builder::
    An Eclipse plugin that supports code generation of Ext JS MVC artifacts based on the code written in Java. CDB comes with wizards to start new project with plain Java or with popular frameworks including Hibernate, Spring, and MyBatis.

Clear JS::
    A set of JavaScript components that extends the Ext JS standard components. In particular, it includes a `ChangeObject` that traces the modifications of any item in a store. 

Clear Runtime::
    Java components that implement the server-side part of +ChangeObject+, +DirectOptions+, and others.

CDB is distributed as a plug-in for Eclipse, a popular Java IDE. The current update site of CDB is located http://cleartoolkit.com/downloads/plugins/extjs/cleardatabuilder/4.1.4/[here].  As of this writing, the current version is 4.1.4. You can install this plug-in via the Install New Software menu in Eclipse. <<FIG6-1-CDB>> shows Clear Data Builder for Ext JS Feature in the list of Installed Software in your Eclipse IDE, which means that CDB is installed.((("productivity tools", "Clear Data Builder (CDB)", "installing")))((("Clear Data Builder (CDB)", "installing")))

NOTE: You have to work with the Eclipse IDE for Java EE Developers, which includes plug-ins for automating web application development.

[[FIG6-1-CDB]]
.Verifying CDB installation
image::images/ewdv_0504.png[image]

Clear Data Builder comes with a set of prepared examples that demonstrate its integration with the popular Java frameworks, MyBatis, Hibernate, and Spring. There is also a plain Java project example that doesn't use any persistence frameworks. Let's start with the creation of a new project: from the Eclipse menu, choose File -> New -> Other -> Clear. You'll see a window similar to <<FIG6-2-CDB>>.((("productivity tools", "Clear Data Builder (CDB)", "new project creation")))((("Clear Data Builder (CDB)", "new project creation"))) 

[[FIG6-2-CDB]]
.New CDB Project Wizard
image::images/ewdv_0505.png[image]

Name the new project +episode_1_intro+. CDB supports different ways of linking the Ext JS framework to the application. CDB automatically copies the Ext JS framework under the web server (Apache Tomcat, in our case). We're going to use this local Ext JS URL, but you can specify any folder in your machine, and CDB will copy the Ext JS file from there into your project. You can also use Ext JS from the Sencha content delivery network (CDN), if you don't want to store these libraries inside your project. Besides, using a common CDN will allow web browsers to reuse the cached version of Ext JS. 

For this project, we are not going to use any server-side persistence frameworks like MyBatis or Hibernate. Just click the Finish button, and you'll see some some initial CDB messages on the Eclipse console. When CDB runs for the first time, it creates in your project's +WebContent+ folder the directory structure recommended by Sencha for Model-View-Controller (MVC) applications. It also generates +index.html+ for this application, which contains the link to the entry point of our Ext JS application. 

CDB generates an empty project with one sample controller and one view, +Viewport.js+. To run this application, you need to add the newly generated dynamic web project to Tomcat and start the server (right-click Tomcat in the Servers view of Eclipse). See <<FIG6-3-CDB>>.

[[FIG6-3-CDB]]
.Adding the web project to Tomcat
image::images/ewdv_0506.png[image]

Open this application in your web browser at +http://localhost:8080/episode_1_intro+ . Voilà! In less than a couple of minutes, we've created a new dynamic web project with the Ext JS framework and one fancy button, as shown in <<FIG6-4-CDB>>.

[[FIG6-4-CDB]]
.Running the scaffolded application
image::images/ewdv_0507.png[image]

The next step is to make something useful out of this basic application.

[[generating_a_crud_application]]
==== Generating a CRUD Application 

Part 2 of the CDB section covers the process of creating a simple CRUD application that uses Ext JS and Java.((("productivity tools", "Clear Data Builder (CDB)", "generating CRUD applications")))(((CRUD applications, generating))) We'll go through the following steps:

* Create a plain old Java object (POJO) and the corresponding `Ext.data.Model`.
* Create a Java service and populate `Ext.data.Store` with data from that service.
* Use the autogenerated Ext JS application.
* Extend the autogenerated CRUD methods.
* Use `ChangeObject` to track the data changes.

Now let's use CDB to create a CRUD application. You'll learn how turn a POJO into an Ext JS model, namely:

* How to populate the Ext JS store from a remote service
* How to use an automatically generated UI for that application
* How to extend the UI
* What the `ChangeObject` class is for

First, we'll extend the application from Part 1--the CRUD application needs a Java POJO.  To start, create a Java class `Person` in the package `dto`. Then add to this class the properties (as well as getters and setters) `firstName`, `lastName`, `address`, `ssn`, `phone`, and `id`. Add the class  constructor that initializes these properties, as shown in <<LISTING_1>>. 

[[LISTING_1]]
.+Person+ data transfer object
====
[source,java]
-----------------------------------------------------
package dto;

import com.farata.dto2extjs.annotations.JSClass;
import com.farata.dto2extjs.annotations.JSGeneratedId;

@JSClass
public class Person {

  @JSGeneratedId
  private Integer id;
  private String firstName;
  private String lastName;
  private String phone;
  private String ssn;
  
  public Person(Integer id, String firstName, String lastName, 
                                    String phone, String ssn) {
    super();
    this.id = id;
    this.firstName = firstName;
    this.lastName = lastName;
    this.phone = phone;
    this.ssn = ssn;
  }
  
  // Getters and Setters are omitted for brevity
}

-----------------------------------------------------
====


You may also add a `toString()` method to the class. Now you'll need the same corresponding Ext JS model for  the Java class `Person`. Just annotate this Java class with the annotation `@JSClass`, and CDB generates the Ext JS model. 

NOTE: CDB integrates into standard Eclipse a build life-cycle. You don't need to trigger a code generation procedure manually. If you have the Build Automatically option selected in the Project menu, code generation starts immediately after you've saved the file.

The next step is to annotate the `id` field with the CDB annotation `@JSGeneratedId`. This annotation  instructs CDB to treat this field as an autogenerated ID. Let's examine the directory of the Ext JS MVC application to see what's inside the _model_ folder. In the JavaScript section is the folder _dto_, which corresponds to the Java +dto+ package where the `PersonModel` resides, as illustrated in <<FIG6-5-CDB>>. 

[[FIG6-5-CDB]]
.Generated from Java class Ext JS model
image::images/ewdv_0508.png[image]

Clear Data Builder generates two files as recommended by the http://martinfowler.com/dslCatalog/generationGap.html[Generation Gap pattern], which is about keeping the generated and handwritten parts separate by putting them in different classes linked by inheritance. Let's open the person model. In our case, `PersonModel.js` is extended from the generated `_PersonModel.js`. Should we need to customize this class, we'll do it inside +Person.js+, but this underscore-prefixed file will be regenerated each and every time when we change something in our model. CDB follows this pattern for all generated artifacts--Java services, Ext JS models, and stores. This model contains all the fields from our Person data transfer object (DTO).(((Generation Gap pattern)))(((design patterns, Generation Gap))) 

Now we need to create a Java service to populate the Ext JS store with the data. Let's create the Java  interface `PersonService` in the package `service`. This service will return the list of `Person` objects. This interface contains one method: `List<Person> getPersons()`. 

To have CDB expose this service as a remote object, we'll use the annotation called `@JSService`.  Another annotation, `@JSGenetareStore`, will instruct CDB to generate the store. In this case, CDB will create the _destination-aware store_. This means that the store will know from where to populate its content. All configurations of the store's proxies will be handled by the code generator. With the `@JSFillMethod` annotation, we will identify our main read method (the _R_ in CRUD).

Also it would be nice to have some sort of sample UI to test the service; the annotation `@JSGenerateSample` will help here. CDB will examine the interface `PersonService`, and based on these annotations, will generate all Ext JS MVC artifacts (models, views, controller) and the sample application. See <<LISTING_2>>.

[[LISTING_2]]
.+PersonService+ interface annotated with CDB annotations
====
[source,java]
----------------------------------------------------------------------
@JSService
public interface PersonService {
    @JSGenerateStore
    @JSFillMethod
    @JSGenerateSample
    List<Person> getPersons();
}
----------------------------------------------------------------------
====


When the code generation is complete, you'll get the implementation for the service: `PersonServiceImpl`. The _store_ folder inside the application folder (+WebContent/app+) has the Ext JS store, which is bound to the previously generated `PersonModel` (see <<FIG6-6-CDB>>). In this case, CDB generated the store that binds to the remote service. 

[[FIG6-6-CDB]]
.Structure of store and model folders
image::images/ewdv_0509.png[]

All this intermediate translation from JavaScript to Java, and from Java to JavaScript, is done by DirectJNgine, which is a server-side implementation of the Ext Direct protocol. You can read about this protocol in http://www.sencha.com/products/extjs/extdirect[Ext JS documentation]. 

CDB has generated a sample UI for us, too. Check out the _samples_ directory shown in <<FIG6-7-CDB>>.

[[FIG6-7-CDB]]
.Folder with generated UI files
image::images/ewdv_0510.png[]

CDB has generated _SampleController.js_, _SampleGridPanel.js_, and the Ext JS application entry point _sampleApp.js_. To test this application, just copy the file _SampleController.js_ into the _controller_ folder, _SampleGridPanel.js_ panel into the _view folder_, and the sample application in the root of the _WebContent_ folder. Change the application entry point to be _sampleApp.js_ in _index.html_ of the Eclipse project, as shown here.

[source,html]
----------------------------------------------------------------------
<script type="text/javascript" src="sampleApp.js"></script>
----------------------------------------------------------------------

The generated UI of the sample application looks like <<FIG6-8-CDB>>.

[[FIG6-8-CDB]]
.A scaffolded CRUD application template
image::images/ewdv_0511.png[image]
On the server side, CDB also follows the _Generation Gap Pattern_ and generates stubs for the service methods. Override these methods when you're ready to implement the CRUD functionality, similar to <<LISTING_3>>. 

[[LISTING_3]]
.Implementation of +PersonService+ interface
====
[source,java]
----------------------------------------------------------------------
package service;
import java.util.ArrayList;
import java.util.List;

import clear.data.ChangeObject;
import dto.Person;
import service.generated.*;

public class PersonServiceImpl extends _PersonServiceImpl { // <1>

  @Override
  public List<Person> getPersons() {                        // <2>
      List<Person> result = new ArrayList<>();
      Integer id= 0;
      result.add(new Person(++id, "Joe", "Doe", 
                      "555-55-55", "1111-11-1111"));
      result.add(new Person(++id, "Joe", "Doe", 
                      "555-55-55", "1111-11-1111"));
      result.add(new Person(++id, "Joe", "Doe", 
                      "555-55-55", "1111-11-1111"));
      result.add(new Person(++id, "Joe", "Doe", 
                      "555-55-55", "1111-11-1111"));
      return result;                    // <3>
  }

  @Override
  public void getPersons_doCreate(ChangeObject changeObject) { // <4>
      Person dto = (Person) deserializeObject(
                      (Map<String, String>) changeObject.getNewVersion(),
                      Person.class);

      System.out.println(dto.toString());
  }

  @Override
  public void getPersons_doUpdate(ChangeObject changeObject) { // <5> 
      // TODO Auto-generated method stub
      super.getPersons_doUpdate(changeObject);
  }

  @Override
  public void getPersons_doDelete(ChangeObject changeObject) { // <6>
      // TODO Auto-generated method stub
      super.getPersons_doDelete(changeObject);
  }
}
----------------------------------------------------------------------
====

<1> Extend the generated class and provide the actual implementation.

<2> The `getPerson()` is our retrieve (fill) method (the _R_ in CRUD).

<3> For this sample application, we can use the `java.util.ArrayList` class as in-memory server-side storage of the `Person` objects. In real-world applications, you'd use a database or other persistent storage.

<4> +fillMethodName+ +`_doCreate()` is our create method (the _C_ in CRUD).

<5> +fillMethodName+ +`_doUpdate()` is our update method (the _U_ in CRUD).

<6> +fillMethodName+ +`_doDelete()` is our delete method (the _D_ in CRUD).

Click the +Load+ menu on the UI, and the application will retrieve four persons from our server.

To test the rest of the CRUD methods, we'll ask the user to insert one new row, modify three existing ones, and remove two rows by using the generated web client. The +Clear.data.DirectStore+ object will automatically create a collection of six ++ChangeObject`s++--one to represent a new row, three to represent the modified ones, and two for the removed rows.

When the user clicks the Sync UI menu, the changes will be sent to the corresponding `do...` remote method. When you `sync()` a standard `Ext.data.DirectStore`, Ext JS is ++POST++-ing new, modified, and deleted items to the server. When the request is complete, the server's response data is applied to the store, expecting that some items can be modified by the server. In case of `Clear.data.DirectStore`, instead of passing around items, we pass the deltas, wrapped in `ChangeObject`.

Each instance of the `ChangeOject` contains the following:

+newVersion+::
    This is an instance of the newly inserted or modified item. On the Java side, it's available via `getNewVersion()`.
+prevVersion+::
    An instance of the deleted old version of the modified item. On the Java side it's available via `getPrevVersion()`.
array of +changepropertyNames+::
    An array of +changepropertyNames+ will exist with instances of `ChangeObject` if it's an update operation.

The rest of the `ChangeObject` details are described in the https://github.com/Farata/ClearJS/wiki/Change-Object%3A-Synchronization-Keystone[Clear Toolkit Wiki].

The corresponding Java implementation of `ChangeObject` is available on the server side, and Clear Toolkit passes `ChangeObject` instances to the appropriate `do*` method of the service class. Take a look at the `getPersons_doCreate()` method in <<LISTING_3>>. When the server needs to read the new or updated data arrived from the client, your Java class has to invoke the method `changeObject.getNewVersion()`. This method will return the JSON object that you need to deserialize into the object `Person`. This is done in <<LISTING_3>> and looks like this:

[source,java]
----------------------------------------------------------------------
 Person dto = (Person) deserializeObject(
            (Map<String, String>) changeObject.getNewVersion(),Person.class);
----------------------------------------------------------------------

When the new version of the `Person` object is extracted from `ChangeObject`, you can do with it whatever has to be done to persist it in the appropriate storage. In our example, we just print the new person information on the server-side Java console. This is why we said earlier that it might be a good idea to provide a pretty printing feature on the class `Person` by overriding the method `toString()`. Similarly, when you need to do a delete, `changeObject.getPrevVersion()` would give you a person to be deleted.


==== Data Pagination 

The pagination feature is needed in almost every enterprise web application. Often you don't want to bring all the data to the client at once; a page-by-page feed brings the data to the user a lot faster. The user can navigate back and forth between the pages by using pagination UI components. To do that, we need to split our data on the server side into chunks, to send them page by page by the client request. Implementing pagination is the agenda for this section.(((CRUD applications, adding data pagination to)))((("productivity tools", "Clear Data Builder (CDB)", "data pagination")))((("Clear Data Builder (CDB)", "data pagination")))(((data pagination)))(((pagination)))

We'll add data pagination to our sample CRUD application by doing the following:

    * Add the `Ext.toolbar.Paging` component.
    * Bind both _grid_ and _pagingtoolbar_ to the same store.
    * Use the `DirectOptions` class to read the pagination parameters.

We are going to improve our CRUD application by adding the paging toolbar component bound to the same store as the grid. The class `DirectOptions` will handle the pagination parameters on the server side. 

So far, CDB has generated the UI from the Java back-end service as well as the Ext JS store and model. We'll refactor the service code from the previous example to generate more data (a thousand objects) so we have something to paginate; see <<LISTING_4>>. 

[[LISTING_4]]
.Refactored implementation of +PersonService+ interface
====
[source,java]
----------------------------------------------------------------------
public class PersonServiceImpl extends _PersonServiceImpl {
  @Override
    public List<Person> getPersons() {
        List<Person> result = new ArrayList<>();
        for (int i=0; i<1000; i++){
            result.add(new Person(i, "Joe", "Doe", "555-55-55", 
                                                   "1111-11-1111"));
        }
        return result;
    }   
}
----------------------------------------------------------------------
====


If you rerun the application now, the Google Chrome console will show that `PersonStore` is populated with 1,000 records. Now we'll add the the Ext JS paging `toolbarpaging` UI component to the file _sampleApp.js_, as shown <<LISTING_5>>. 

[[LISTING_5]]
.Sample application entry
====
[source,javascript]
-----------------------------------------------------
Ext.Loader.setConfig({
  disableCaching : false,
  enabled : true,
  paths : {
    episode_3_pagination : 'app',
    Clear : 'clear'
  }
});

Ext.syncRequire('episode_3_pagination.init.InitDirect');
// Define GridPanel
var myStore = Ext.create('episode_3_pagination.store.dto.PersonStore',{}); //<1>
Ext.define('episode_3_pagination.view.SampleGridPanel', {
  extend : 'Ext.grid.Panel',
  store : myStore,
  alias : 'widget.samplegridpanel',
  autoscroll : true,
  plugins : [{
    ptype : 'cellediting'
  }],
  dockedItems: [
    {
      xtype: 'pagingtoolbar',   //<2>
      displayInfo: true,
      dock: 'top',
      store: myStore      //<3>
    }
  ],
  columns : [
    {header : 'firstName', dataIndex : 'firstName', 
                  editor : {xtype : 'textfield'}, flex : 1 },
    {header : 'id', dataIndex : 'id', flex : 1 },
    {header : 'lastName', dataIndex : 'lastName', 
                  editor : {xtype : 'textfield'}, flex : 1 },
    {header : 'phone', dataIndex : 'phone', 
                  editor : {xtype : 'textfield'}, flex : 1 },
    {header : 'ssn', dataIndex : 'ssn', 
                  editor : {xtype : 'textfield'}, flex : 1 }],
  tbar : [
    {text : 'Load', action : 'load'},
    {text : 'Add', action : 'add'},
    {text : 'Remove', action : 'remove'},
    {text : 'Sync', action : 'sync'}
    ]
  });
// Launch the application
Ext.application({
  name : 'episode_3_pagination',
  requires : ['Clear.override.ExtJSOverrider'],
  controllers : ['SampleController'],
  launch : function() {
    Ext.create('Ext.container.Viewport', {
      items : [{
        xtype : 'samplegridpanel'
      }]
    });
  }
});

-----------------------------------------------------
====


<1> Manual store instantiation: create a separate variable `myStore` for this store with an empty `config` object.
<2> Add the `xtype` `pagingtoolbar` to this component's docked items property to display the information and dock this element at the top.
<3> Now the paging toolbar is also connected to same store.

The next step is to fix the automatically generated controller to take care of loading data upon clicking the Load button, as shown in <<LISTING_6>>. 

[[LISTING_6]]
.Controller for sample application
====
[source,javascript]
-----------------------------------------------------
Ext.define('episode_3_pagination.controller.SampleController', {
  extend: 'Ext.app.Controller',
  stores: ['episode_3_pagination.store.dto.PersonStore'],
  refs: [{                //<1>
    ref: 'ThePanel',
    selector: 'samplegridpanel'
  }],

  init: function() {
    this.control({
      'samplegridpanel button[action=load]': {
        click: this.onLoad
      }
    });
  },

  onLoad: function() {
    // returns instance of PersonStore
    var store = this.getThePanel().getStore();    //<2>
    store.load();
  }
});
-----------------------------------------------------
====


<1> Bind the store instance to our grid panel. In the controller's `refs` property, we're referencing our  `simplegrid` panel with `ThePanel` alias.

<2> In this case, there is no need to explicitly retrieve the store instance by name. Instead, we can use the getters `getPanel()` and `getStore()`, which were automatically generated by the Ext JS framework.

When the user clicks the Next or Previous button, the method `loadPage` of the underlying store is called. Let's examine the `directprovider` URL--the server-side router of the remoting calls--to see what this direct request looks like. Open Google Chrome Developer Tools by choosing View -> Developer, refresh the web page, and then go to the Network tab. You'll see that each time the user clicks the _next_ or _previous_ button on the pagination toolbar, the component sends `directOptions` as a part of the request.

The default Ext Direct request doesn't carry any information about the page size. Clear JS has the client-side extension of the Ext JS framework that adds some extra functionality to the `Ext.data.DirectStore` component to pass the page `start` and `limit` values to the server side. At this point, the `directOptions` request property (see <<FIG6-9-CDB>>) can be extracted on the server side to get the information about the page boundaries. Let's add some code to _PersonServiceImpl.java_. At this point, the pagination doesn't work. The server sends the entire thousand records, because it doesn't know that the data has to be paginated. We'll fix it in <<FIG6-9-CDB>>. 

[[FIG6-9-CDB]]
.Request payload details
image::images/ewdv_0512.png[image]

[[LISTING_7]]
.Implementation of +PersonService+ with pagination
====
[source,java]
----------------------------------------------------------------------
package service;
import java.util.ArrayList;
import java.util.List;

import clear.djn.DirectOptions;     //<1>

import dto.Person;
import service.generated.*;

public class PersonServiceImpl extends _PersonServiceImpl {
  @Override
  public List<Person> getPersons() {
    List<Person> result = new ArrayList<>();
    for (int i=0; i<1000; i++){
      result.add(new Person(i, "Joe", "Doe", "555-55-55","1111-11-1111"));
    }
    //<2>
    int start = ((Double)DirectOptions.getOption("start")).intValue();
    int limit = ((Double)DirectOptions.getOption("limit")).intValue();
    
    limit = Math.min(start+limit, result.size() );    //<3>
    DirectOptions.setOption("total", result.size());  //<4>
    result = result.subList(start, limit);      //<5>

    return result;
  }
}
----------------------------------------------------------------------
====

<1> On the server side, there is a special object called `DirectOptions`, which comes with Clear Toolkit.

<2> We want to monitor the `start` and `limit` values (see <<FIG6-9-CDB>>).

<3> Calculate the actual limit. Assign the size of the data collection to the `limit` variable if it's  less than the page size (`start+limit`).

<4> Notify the component about the total number of elements on the server side by using the `DirectOptions.setOption()` method with the `total` option.

<5> Before returning the result, create a subset, an actual page of data using the method `java.util.List.sublist()`, which produces the view of the portion of this list between indexes specified by the `start` and the `limit` parameters.  

As you can see on the Network tab in <<FIG6-8-CDB>>, we've limited the data load to 25 elements per page. Clicking the Next or Previous button will get you only a page worth of data. The Google Chrome Developer Tools Network tab shows that we are sending the `start` and `limit` values with every request, and the response contains the object with 25 elements.

If you'd like to repeat all of the preceding steps on you own, watch http://faratasystems.com/training-at-farata-youtube-chanel/[the screencasts] demonstrating all the actions described in the section on CDB. For current information about CDB, visit http://cleardb.io/[cleardb.io].

=== Summary

Writing enterprise web applications can be a tedious and time-consuming process. A developer needs to set up frameworks, boilerplates, abstractions, dependency management, and build processes, and the list of requirements for a front-end workflow appears to grow each year. In this chapter, we introduced several tools that can help you automate a lot of mundane tasks and make you more productive.

