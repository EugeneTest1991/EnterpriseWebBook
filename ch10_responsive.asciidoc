= Responsive Web Design and Mobile Devices

[partintro]
--
_BYOD_ stands for _bring your own device_. It has became a new trend as a result of the increasing number of enterprises that started allowing their employees to access corporate applications from personal tablets or smartphones. 

_CYOD_ stands for _choose your own device_. In this paradigm, corporations let their employees choose from a set of devices that belong to the enterprise. CYOD is about selecting a strategy that organizations should employ while approving new devices.

Developers of new web applications should always think of the users who will try to run the application on a mobile device. This part of the book is about various strategies for developing web applications that look and perform well on both desktop computers and smaller screens.

Today, most enterprise applications are still being developed for desktop computers. The situation is changing, but it's a slow process. If five years ago it was close to impossible to get permission to bring your own computer to work and use it for work-related activities, the situation is entirely different now with BYOD and COYD. 

Sales people want to use tablets while dealing with prospective clients. Business analysts want to be able to run familiar web applications on their smartphones. Enterprises want to offer external access access to valuable data from a variety of devices. 

In <<responsive_design>> we explain _responsive web design_ (RWD) and how you can build an HTML5 application that has a single code base for desktops, tablets, and smartphones. We'll apply responsive design principles and redesign our Save The Child application to have a http://savesickchild.org:8080/ssc-responsive/[fluid layout] so that it will remain usable on smaller screens, too.

Another approach is to have separate versions of the application for desktops and mobile devices. <<jquery_mobile>> and <<sencha_touch>> demonstrate how to create dedicated mobile versions of web applications with the jQuery Mobile library and Sencha Touch framework, respectively. And the Save The Child application is rewritten in each of these chapters.

But if using RWD allows you to have a single code base for all devices, you might be wondering, why not just build every web application this way? RWD works fine for sites that mainly publish information. But if users are expected not just to read, but also to input data on small-screen devices, the UI and the navigation might need to be custom designed to include only partial functionality while each page view provides the best user experience. Besides, with responsive design, the code and CSS for all devices is loaded to a user's smartphone, making the application unnecessarily large and slow when the connection speed is not great.

With small screens, you have to rethink carefully about which widgets are must-haves and what functionality is crucial to the business for which you're creating a web application. If it's a restaurant, you need to provide an easy way to find the menu, phone, address, and directions to your location. If it's a site to collect donations, like our Save The Child, the design should provide an easy way to donate, while the rest of the information should be hidden by simple navigational menus.

On rare occasions, an enterprise application is created solely for mobile platforms. More often, the task is to migrate an existing application to a mobile platform or develop separate versions of the same application for desktops and mobile devices. If a decision is made to develop native mobile applications, the choice of programming languages is dictated by the mobile hardware. 

If it's a web application, using the same library or framework for desktop and mobile platforms can shorten the development cycle. That's why we decided to cover such pairs in this book, namely: 

* jQuery and jQuery Mobile 

* Ext JS and Sencha Touch

But even though each of these pairs shares the same code for core components, do not expect to be able to kill two birds with one stone. You are still going to use different versions of the code--for example, jQuery 2.0 and jQuery Mobile 1.3.1. This means that you might have to deal with separate bugs that sneaked into the desktop and mobile version of the frameworks.

What's better: jQuery Mobile or Sencha Touch? There is no general answer to this question. It all depends on the application you're building. If you need a simple mobile application for displaying various information (a publishing type of application), jQuery Mobile will do the job with the least effort. If you are building an application that requires some serious data processing, Sencha Touch is a better choice. Of course, lots of other frameworks and libraries are available that can help you develop a mobile web application. Do your homework and pick the one that best fits your needs. 

There's a http://www.markus-falk.com/mobile-frameworks-comparison-chart/[website] that compares mobile frameworks. It even has a little wizard application with which you can pick a framework that meets your needs and is supported on required devices. <<FIG12-1>> is a fragment snapshot from this site. As you can see, jQuery Mobile supports the largest number of platforms.

[[FIG12-1]]
.A fragment of the Mobile Frameworks Matrix
image::images/ewdv_04.png[]

TIP: A framework called http://zeptojs.com/[Zepto] is a minimalist JavaScript library with an API compatible to jQuery. Zepto supports both desktop and mobile browsers.


Finally, in <<hybrid_mobile_apps>> we talk about yet another approach for developing HTML5 applications for mobile devices: _hybrid_ applications. These applications are written in JavavaScript but are packaged as native apps. You'll learn how Adobe's PhoneGap can package an HTML5 application to be accepted in online stores where native applications are being offered. To illustrate accessing hardware features of a mobile device, we show you how to access the device's camera; this can be a useful feature for the Save The Child application.  
--

[[responsive_design]]
== Responsive Design: One Site Fits All

Up until now, we've been writing and rewriting the desktop version of the Save The Child application. Will it look good on the small screen of a mobile device? Beginning with this chapter, we'll deal with mobile devices, too.

Let's discuss different approaches to developing a web application that can work on both desktop and mobile devices. There are three choices:

Seperate versions of native applications::
    In addition to your web application that works on desktops, develop a separate version of the native application for multiple mobile devices. Development of native mobile applications is not covered in this book.

Single HTML applications with multiple UIs::
    Develop a single HTML5 web application, but create various UI layouts that will be applied automatically, based on the screen size of the user's device.

Hybrid applications::
    In addition to your web application that works on desktops, develop a _hybrid application_. This web application on steroids works inside the mobile browser but is packaged as a native app and can invoke the native API of the mobile device, too. <<hybrid_mobile_apps>> is dedicated to hybrid applications.

This chapter focuses the second approach, called _responsive web design_ (RWD). This term was coined by Ethan Marcotte in his article http://www.alistapart.com/articles/responsive-web-design/[Responsive Web Design]. The concept that underlies RWD is that the design of the web page changes, responding (reacting) to the display size of the user's device. We'll modify the design of the Save The Child site to introduce different layouts for the desktop, tablet, and smart phones. By the end of this chapter, the site Save The Child will automatically change its layout (without losing functionality) based on the screen size of the user's device. 


=== One or Two Versions of Code?

Run any version of our Save The Child from the first chapters on your desktop and start dragging the right border of the browser's window to make it narrower. At some point, you'll see only part of the content; those layouts were not meant to be responsive. The application defines fixed sizes for page sections, which don't change even if the display area shrinks. 

Enter *http://savesickchild.org* in your mobile phone's browser. Select the version titled HTML/AJAX. You'll see either partial content on the page or the entire page with illegible small, fonts as in <<FIG11-0>>. This design of the Save The Child application doesn't look good on all devices.  

[[FIG11-0]]
.Nonresponsive version of the app on iPhone 5
image::images/ewdv_1001.png[]

Now try the version titled Responsive Design; this looks more usable on a small screen. Of course, this begs the question: how many versions of the UI do we need to create? People responsible for developing web applications that can run on both desktop and mobile platforms usually begin by making an important decision: HTML5 or native?  But even if a decision is made in the favor of the web platform, the next question is whether desktop and mobile clients will use the same code.

If a decision is made to go with separate versions of the web application, the web server can be configured to perform redirection to the appropriate code depending on the type of device the user has. Web servers can do it based on the value of the `User-Agent` attribute of the HTTP request header. For example, mobile web browsers trying to access the http://www.bbc.com/[BBC] (or any other web page) report their `User-Agent` to the server differently from desktop computers; hence, they receive different content delivered from a different URL. <<FIG11-1>> and <<FIG11-2>> show snapshots of the BBC main page that were taken at the same time. <<FIG11-1>> shows how the page looks on a desktop computer, whereas <<FIG11-2>> was taken on an iPhone. 

TIP: The Safari browser has a Develop menu, where you can select various User Agents to see how the current web page will look on different web browsers. You can also copy and paste a User Agent string from the site http://www.useragentstring.com/pages/useragentstring.php[useragentstring.com] to see how a web page will look in hundreds of devices if the website is user-agent driven.

[[FIG11-1]]
.The desktop version of bbc.com
image::images/ewdv_1002.png[]

The page layout shown in <<FIG11-1>> delivers more content because that content can be allocated nicely on a large desktop monitor or a tablet. But the mobile version shown in <<FIG11-2>> substantially limits what's delivered to the client--not only because the screen is small, but because user might be accessing the page over a slower network.

[[FIG11-2]]
.The mobile version of bbc.com
image::images/ewdv_1003.png[]

Have you ever tried to share the link of a website specifically designed for smartphones? It's so easy! Just press the button and enter the email of the person with whom you want to share the site. Many mobile websites shared this way won't look pretty on the large screen. It might just show a wider version of what you see on your mobile screen. 

Maintaining two versions of the application code requires more effort than maintaining one: you need to have two sets of HTML, CSS, JavaScript, and images. Besides, most likely your web application will use a third-party JavaScript framework. At some point, you might run into a bug and will need to upgrade the mobile version to use the latest version of, say, the jQuery framework. But the desktop version works just fine. If you have two separate versions of the application, you'll have to either upgrade jQuery and thoroughly test both mobile and desktop versions of Save The Child, or live with two versions of the framework. 

Responsive design makes it possible for you to create one version of the web application, which includes multiple sections of CSS controlling page layouts for different screen sizes. In this chapter, we'll create yet another version of the  Save The Child application that will render its UI differently on desktop and mobile devices. All these version, will share the same HTML and JavaScript code, but will include several screen layouts using _CSS media queries_. 

Many websites have been built using responsive design. The list that follows presents several examples. Take a few moments to look at them, first from a desktop computer and then from a smartphone (or just lower the width of the desktop browser window), to experience fluid responsive design:

* http://bostonglobe.com/[Boston Globe]
* http://mashable.com/[Mashable]
* http://cafeevoke.com/[Cafe Evoke]
* http://www.fork-cms.com/[Fork CMS]
* http://mediaqueri.es/[A lot more examples]


Note that each of these web pages displays content on the desktop in three layouts (often in three, four, six, or twelve imaginary columns). As you make the window narrower, the layout automatically switches to a tablet or a large smartphone mode (usually a two-column layout), and then to the phone mode layout (the one-column layout). 

This sounds like a great solution, but if you put all your media queries in the same CSS files, your users will be downloading unnecessary bytes--the entire CSS file that includes all versions of screen layouts. This is not the case in the BBC example, which has different versions of the code that load only what's necessary for a particular device category.

You can have several CSS files for different devices. Include these files by using the media attributes. But web browsers were not designed to selectively download only those CSS files that are needed. For example, the following HTML loads both CSS files (http://www.igvita.com/2012/06/14/debunking-responsive-css-performance-myths/[without blocking rendering]) on any user's device:

[source, html]
----
<link media="only screen and (max-width: 480px)" 
      href="css/smartphone.css"rel="stylesheet">

<link media="only screen and (max-width: 768px)" 
      href="css/tablet.css"rel="stylesheet">
----

NOTE: Using the `Window.matchMedia` attribute can make it possible for you to http://christianheilmann.com/2012/12/19/conditional-loading-of-resources-with-mediaqueries/[conditionally load] CSS in JavaScript. 
The JavaScript utility https://github.com/scottjehl/eCSSential[eCSSential] can help web browsers download CSS faster. 
 
NOTE: Consider combining responsive design on the client with some device-specific component (a.k.a. http://www.lukew.com/ff/entry.asp?1392[RESS]) optimization on the server.

TIP: Although responsive design allows you to rearrange content based on the screen size, it might not be a good idea to show the same amount of content on desktops and smartphones. Making a web application look good on mobile devices must involve not only web designers and developers, but also people who are responsible for content management. 

Now comes the million-dollar questions: Do we need to create 2 versions of the web application or 22?  Why not 222? How many different mobile devices are there today, and will there be tomorrow?


==== How Many User Agents Are There

The HTTP header's attribute `User-Agent` contains information about the user agent originating the request. Should you decide to create several versions of the UI based on the value in the `User-Agent` field, you can refer to the website http://useragentstring.com[http://useragentstring.com]. It lists not two, but hundreds of strings representing possible content of the `User-Agent` attribute for a variety of desktop and mobile devices. For example, <<FIG11-3>> shows how the `User-Agent` string from iPhone 5 is reported and explained by http://useragentstring.com/[useragentstring.com]. But this information might become unreliable after iOS upgrades. 


[[FIG11-3]]
.The User-Agent string from iPhone 5
image::images/ewdv_1004.png[]


There is an easier way to detect on the server that the request came from a mobile device. http://wurfl.sourceforge.net/[_Wireless Universal Resource File_ (WURF)] is a database of thousands of supported devices and their properties. Such Internet giants as Facebook and Google rely on this service, and your application could, too, if need be. WURF offers APIs from several programming languages to detect specific capabilities of user devices. For example, the following code snippet is how you could access the WURF data from a Java servlet:

[source, html]
----
 protected void processRequest(HttpServletRequest request, 
                               HttpServletResponse response) 
          throws ServletException, IOException {

   WURFLHolder wurfl = (WURFLHolder)getServletContext()
   .getAttribute(WURFLHolder.class.getName());
    
   WURFLManager manager = wurfl.getWURFLManager();

   Device device = manager.getDeviceForRequest(request);
    
   log.debug("Device: " + device.getId());
   log.debug("Capability: " + device.getCapability("preferred_markup"));
----

It's impossible to create different layouts of a web application for thousands of user agents. Market fragmentation in the mobile world is a challenge. People are using 2,500 different devices to connect to Facebook. The Android market in particular is extremely fragmented. <<FIG11-3-1>> is taken from the report http://opensignal.com/reports/fragmentation-2013/[Android Fragmentation Visualized (July 2013)] by Open Signal.  

[[FIG11-3-1]]
.Android device fragmentation
image::images/ewdv_1005.png[]

Of course, device fragmentation doesn't equal Android OS version fragmentation, but this situation is similar to the challenge that Microsoft has always faced--making sure that Windows works fine on thousands of types of hardware. It's not an easy job to do. In this regard, Apple is in a much better position because they are the only hardware and software vendor of all devices running iOS. 

It's great for consumers that Android can be used on thousands of devices, but what about us, the developers? Grouping devices by screen sizes might be a more practical approach for lowering the number of UI layouts supported by your application. Responsive design is a collection of techniques based upon these main pillars:

* CSS media queries 
* Fluid grids or fluid layouts
* Fluid media 

NOTE: Typography can be also considered one of the pillars of responsive design. This subject belongs to publications written for web designers and will not be covered in this book. Oliver Reichenstein's article http://ia.net/blog/responsive-typography-the-basics/[Responsive Typography: The Basics] is a good introduction to this topic.

https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Media_queries[media query] is a CSS element. It consists of a media type (for example, +@media (min-width: 700px) and (orientation: landscape)+) followed by the styles applicable to this media. Using media queries, you can rearrange sections (`<div>`, `<section>`, `<article>`, and so forth) of the page based on the screen size. Fluid grids make it possible for you to properly align and scale the content of these sections. Fluid media is about resizing images or videos.

Data grid components are often included in enterprise applications. Fluid grids are designed by using relative positioning and can scale based on screen sizes. Fluid media is about creating videos and images that react to screen sizes. We'll talk about the aforementioned pillars in greater detail later in this chapter. But before going into technical details, let's get back to creating mock-ups, as we did in <<mocking_up_the_app>>, to see how the UI should look on different devices.

=== Back to Mockups

Recall Jerry, our web designer who we introduced in <<mocking_up_the_app>>. Well, he has come up with another set of Balsamiq mockups for the Save The Child application. This time he has four versions: desktop, tablet, large smartphone, and small smartphone. As a matter of fact, Jerry has provided more mockups to accommodate the user holding both smartphones and tablets either in portrait or landscape mode. <<FIG11-4>> shows the desktop mockup.


[[FIG11-4]]
.The desktop layout
image::images/ewdv_1006.png[]

Jerry gives us several versions of the images--with and without the grid background. The use of the grid is explained later, in <<fluid_grids>>. <<FIG11-5>> depicts the rendering on tablet devices with a screen that is less than 768 pixels wide in portrait mode.

[[FIG11-5]]
.The tablet layout (portrait)
image::images/ewdv_1007.png[]

Next comes the mock-up for large smartphones having a width of up to 640 pixels. <<FIG11-6>> shows two images of the screen next to each other (a user would need to scroll to see the second image).

[[FIG11-6]]
.The large phone layout (portrait)
image::images/ewdv_1008.png[]

The mock-up for smaller phones with a width of less than 480 pixels is shown in <<FIG11-7>>. The mock-up looks wide, but it actually shows three views of the phone screen next to one another. The user would need to scroll vertically to see the middle or the right view. iPhone 3 falls into this category. 

[[FIG11-7]]
.The small phone layout (portrait)
image::images/ewdv_1009.png[]

If need be, you can ask Jerry to create mock-ups for real devices with a width less than 320 pixels, but we won't even try it here. Now we need to translate these mock-ups into working code. The first subject to learn is CSS media queries.  

[[css_media_queries]]
=== CSS Media Queries

First, let's see the CSS media queries in action, and then we'll explain how this magic is done. Run the project titled _Responsive_basic_media_queries_, and it will look like <<FIG11-8>>. This is a version for desktops (or some tablets in landscape mode). The section chart, map, and video divide the window into three imaginary columns. 


[[FIG11-8]]
.The desktop layout implemented
image::images/ewdv_1010.png[]

Drag the right border of your desktop web browser's window to the left to make it narrower. After reaching a certain _breakpoint width_ (in our project it's 768 pixels), you'll see how the ++<div>++s reallocate themselves into the two-column window shown in <<FIG11-9>>.

[[FIG11-9]]
.The tablet layout (portrait) implemented
image::images/ewdv_1011.png[]

Keep making the browser's window narrower; when the width passes another breakpoint (becomes less than 640 pixels), the window will rearrange itself into one long column, as in <<FIG11-10>>. Users will have to scroll to see the lower portion of this window, but they don't lose any content. 

[[FIG11-10]]
.The smaller phone layout (portrait) implemented
image::images/ewdv_1012.png[]

The W3C recommendation titled http://www.w3.org/TR/css3-mediaqueries/[Media Queries] was introduced in CSS2 and HTML 4. The idea was to provide different stylesheets for different media. For example, you can specify different stylesheets in HTML by using the `media` attribute for screens that are less than 640 pixels in width:

[source, html]

----
<link rel="stylesheet" href="assets/css/style.css" media="screen">

<link rel="stylesheet" href="assets/css/style_small.css" 
                       media="only screen and (max-width: 640px)">
----

You might have several of these `<link>` tags for different screen widths. But all of them will be loaded, regardless of the actual size of the user's display area. Modern browsers might preclude loading CSS files that don't match the current display size. 

The other choice is to specify a section in a CSS file by using one or more `@media` rules. For example, the following style will be applied to the HTML element with the `id=main-top-section` if the width of the display area (screen) is less than 640 pixels. +screen+ is not the only media type that you can use with media queries. For example, you can use `print` for printed documents or `tv` for TV devices. For an up-to-date list of media types, see the document http://www.w3.org/TR/css3-mediaqueries/[Media Queries W3C Recommendation].

[source, html]
----
@media only screen and (max-width: 640px) {

  #main-top-section {
		width: 100%;
		float: none;
 }
}
----

Two fragments of the CSS file _styles.css_ from the project _Responsive_basic_media_queries_ are shown next. The first one begins by defining styles for windows having a width of 1280 pixels (we use 1140 pixels to leave some space for padding and browser's chrome). <<ex_CSS_under_1280>> presents the first fragment.

[[ex_CSS_under_1280]]
.CSS for the devices with a width less than 1280 pixel
====
[source, html]
----

/* The main container width should to be 90% of viewport width */
/* but not wider than 1140px */
#main-container {
	width: 90%;
	max-width: 1140px;            // <1> 
	margin: 0 auto;
}

/* Background color of all elements was set just as an example */
header {
	background: #ccc;
	width: 100%;
	height: 80px;
}

#main-top-section {
	background: #bbb;
	width: 100%;
	height: 300px;
	position: relative;
}

#main-bottom-section {
	width: 100%;
}

#video-container, #map-container, #charts-container {
	width: 33.333%;                   // <2>
	padding-bottom: 33.333%;
	float: left;                      // <3> 
	position: relative;
}

#video, #map, #charts {
	background: #aaa;
	width: 100%;
	height: 100%;
	position: absolute;
	padding: 0.5em;
}

#map {
	background: #999;
}

#charts {
	background: #7d7d7d;
}

footer {
	background: #555;
	width: 100%;
	height: 80px;
	color: #fff;
}
----
====

<1>  Set the maximum width of the window on a desktop to 1140 pixels. It's safe to assume that any modern monitor supports the resolution of 1280 pixels in width (minus about 10 percent for padding and chrome).

<2>  Allocate one-third of the width for video, charts, and maps each.

<3>  Float left instructs the browser to render +<div>+ starting from the left and adding the next one to the right.

This CSS mandates changing page layouts if the screen size is at or is smaller than 768 or 640 pixels. Based on your web designer's recommendations, you can specify as many breakout sizes as needed. Suppose that in the future everyone's monitor is at least 1900 pixels wide; you could provide a layout that would use five imaginary columns. This would be a good idea for online newspapers or magazines, but Save The Child is not a publication, so we'll keep its maximum width within 1140 pixels. Or you might decide to make a version of Save The Child available for LCDs that are only 320 pixels wide; create a new media query section in your CSS and apply fluid grids to make the content readable. <<>> shows the second fragment of the CSS file that defines media queries.

[source, html]
----
/* media queries */

@media only screen and (max-width: 768px) {    // <1>
	#main-container {
		width: 98%
	}

	#main {
		background: #bbb;
	}

	#main-top-section, #main-bottom-section {
		width: 50%;                           // <2> 
		float: left;                          // <3> 
	}

	#main-top-section {
		height: 100%;
	}

	#video-container, #map-container, #charts-container {
		float: none;                         //   <4>
		width: 100%;
		padding-bottom: 70%;
	}

}

@media only screen and (max-width: 640px) {   //  <5>

	#main-top-section, #main-bottom-section {
		width: 100%;                          //  <6>
		float: none;                             
	}

	#main-top-section {
		height: 400px;
	}

	#video, #map, #charts {
		height: 60%;
	}
}
----

<1>	 This media query controls layouts for devices with viewports having the max width of 768px.

<2>  Split the width fifty-fifty between the HTML elements with ID's `main-top-section` and `main-bottom-section`. 

<3> Allocate main-top-section and main-bottom-section next to each other (`float: left;`) as in <<FIG11-9>>. To better understand how the CSS `float` property works, visualize a book page having an small image on the left with the text floating on the right (a text wrap) - this is what `float: left;` can do on a Web page. 

<4>  Turn the floating off so the charts, maps, and video containers will start one under another as in <<FIG11-9>>.

<5>	 The media query controlling layouts for devices with viewports with the max width of 640px starts here.

<6> Let the containers main-top-section, main-bottom-section take the entire width and be displayed one under another (`float: none;`) as in <<FIG11-10>>.

TIP: Internet Explorer 8 and older don't natively support media queries. Consider using Modernizr to detect support of this feature, and load the https://github.com/h5bp/mobile-boilerplate/wiki/Media-Queries-Polyfill[Media Queries Polyfill], if needed. 	

.The Viewport Concept
*****************************

Mobile browsers use a concept of _viewport_, which is a virtual window where they render the Web page content. This virtual window can be wider than the actual width of the display of the user's mobile device. For example, by default iOS Safari and Opera Mobile render the page to the width of 980px, and then shrinks it down to the actual width (320px on old iPhones and 640px on iPhone 4 and 5). That's why your iPhone renders the entire Web page of, say New York Times (yes, the fonts are tiny), and not just its top left section.

By using the meta tag `viewport` your Web page overrides this default and renders itself according to the actual device size.  All code samples in this chapter include the `viewport` meta tag in index.html. All mobile browsers support it even though it's not a part of the HTML standard yet. Desktop browsers ignore the tag `viewport`.

[source, html]
----
<meta name="viewport" content="width=device-width, initial-scale=1.0">
----

This meta tag tells the browser that the width of the virtual viewport should be the same as the width of the display. This setting will produce good results if your responsive Web design includes a version of the page layout optimized for the width of the current user's device. But if you'd be rendering a page with a fixed width, which is narrower than the default width of the display (e.g. 500 pixels) setting the attribute `content="width=500"` would instruct the mobile Web browser to scale the page to occupy the entire display real estate. In other words, setting a fixed width is like saying, "Dear mobile browser, I don't have a special layout for this device width - do the best you can ans scale the content".

Setting the initial scaling to 1.0 ensures that the page will be rendered as close to the physical device size as possible. If you don't want to allow the user scale the Web page, add the attribute `user-scalable=no` to the meta tag `viewport`. 

WARNING: If you'll apply the initial scale to be 1.0, but to a Web page that was not build using responsive design principles, users will need to zoom or pan to see the entire page. 

For details about configuring the viewport refer to https://developer.apple.com/library/safari/#documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html[Apple's] or http://dev.opera.com/articles/view/an-introduction-to-meta-viewport-and-viewport/[Opera's] documentation.

*****************************

Some of the important concepts to take away from this example are to switch from pixels to percentages when specifying width. In the next examples you'll see how to switch from using rigid `px` to more flexible `em` units. The CSS `float` property you can control relative (not absolute) positioning of your page components.  There are also such CSS measure units as `vw` and `vh`, which represent percentages of the viewport width and height respectively.
But the best practice here is to use http://css-tricks.com/theres-more-to-the-css-rem-unit-than-font-sizing/[`rem` units]. The app can set the font size on BODY and then specify everything in relative-ems that scale only from that number. `Ems` cascade their scale down from their parent, meaning lots of extra math the developer and the browser has to do.

TIP: Install an Add-On for Google Chrome called https://chrome.google.com/webstore/detail/window-resizer/kkelicaakdanhinjdeammmilcgefonfh?hl=en[Window Resizer]. It'll add an icon to the toolbar for easy switch between the browser screen sizes. This way you can quickly test how your Web page looks on different viewports. There is another handy Add-On for Chrome called https://chrome.google.com/webstore/detail/responsive-inspector/memcdolmmnmnleeiodllgpibdjlkbpim?hl=en[Responsive Inspector], which allows you to see the various media queries for a page and automatically resize to them. 

TIP: Google Chrome Developer Tools offer you a way to test a Web page on various emulators of mobile devices. you just need to check off the "Show Emulation view in console drawer" in Settings, and then you'll see the Emulation tab under the Elements menu (hit the Esc key if it's not shown). 

==== How Many Breakpoints? 

How many media queries is too many? It all depends on the Web page you're designing. In the sample CSS shown in this section above we've used the breakpoint of 768px to represent the width of the tablet in the portrait mode, and this is fine for the iPad. But several tablets (e.g. 10.1" Samsung Galaxy) have 800px-wide viewport while Microsoft Surface Pro is 1080px wide. 

There is no general rule as to how many breakpoint is needed for a typical Web page. Let the content of your page (and where it breaks) dictate where you add breakpoints. Just create a simple Lorem Ipsum prototype of your Web site and start changing its size. At a certain point (viewport size) your design starts to break. This is where you need to put your breakpoint and define a media query for it. 
It is recommended to start with designing for the smallest viewports (the "Mobile First" principle). As the viewport width increases you may decide to render more content hence define a new breakpoint.
Technically this means that the content of your CSS should default to the smaller viewports and only if the screen is larger, apply media queries. Such approach will reduce the CSS handling by the browser of the mobile device (no need to switch from large to smaller layouts).  

TIP: Use Google Chrome Developer Tools to find out the current width of the viewport. Just type in the console `window.innerWidth` and you'll see the width in pixels.

Don't try to create a pixel perfect layout using responsive design. Use common sense and remember, the more different media queries you provide the heavier your CSS file will become. But in mobile world you should try to create Web applications as slim as possible.  

Warning: Be prepared to see inconsistencies among the desktop browsers in measuring the width of the viewport. Our tests showed that WebKit-based browsers add about 15px to the width, supposedly accounting for the width of the scrollbar. So if you have a media query that has to change the layout at 768px, it'll change it at about 783px. Do more testing on different viewports and adjust your CSS as needed.  


[[fluid_grids]]
=== Fluid Grids

Fluid grids is a very important technique in the responsive design. Grids were used by Web designers for ages - a web page was divided by a number of imaginary rows and columns. But the fluid grid, as the name implies, is flexible and can scale based on the screen sizes.

==== Moving Away From Absolute Sizing

When a browser displays text it uses its default font size unless it was overruled by the `font-size` property. Typically, the default font size is 16 pixels. But instead of using the absolute font size, you can use the relative one by using so called _em_ units. The default browser's font size can be represented by 1em. Since the font size happens to be 16px then 1em is 16 px. 

The absolute sizes are enemies of the responsive design Web sites, and specifying the sizes in em unit allows you to create Web pages with the pretty flexible and fluid content. The size can be calculated based on a formula offered by Ethan Markotte in his http://www.alistapart.com/articles/fluidgrids/[article on fluid grids]: `target/context=result`, which in case of fonts becomes `size-in-pixels/16 = size-in-em`. 

For example, instead of specifying the size as 24px, you can set it to 1.5em: 24/16. In your CSS file you can write something like `padding-bottom: 1.5em`. This may seem not a big deal, but it is, because if everything is done in relative sizing, your page will look good and proportional regardless of the screen size and regardless of how big or small 24px may look on a particular screen.

If we are talking about em units for representing font sizes, the font becomes _the context_, but what if you want to represent the width of an arbitrary HTML component in a browser's window or any other container? Then the width of your component becomes the `target` and the total width of the container becomes the `context`. We can still use the above formula, but will multiply the result by 100%. This way the width on an HTML component will be represented not in em, but in percentages relative to the total width of the container. 

Let's say the total width of the browser's window is 768px, and we want to create a 120px-wide panel on the left, instead of specifying this width in pixels we'll use the formula and turn it into percentages.We want to calculate the target's width in percents of the available context (100%): 

120 / 768 * 100% = 15.625% 

Such approach makes the page design _fluid_. If someone decides to open this page on a 480px-wide screen, the panel will still take 15.625% of the screen rather than demanding 120 pixels, which would look substantially wider on a smaller viewport.

==== Window as a Grid

While designing your page you can overlay any HTML container or the entire Web page real estate with imaginary grid with any number of columns. Make it flexible though - the width of each column has to be specified in percentages.

http://www.adobe.com/products/dreamweaver.html[Adobe Dreamweaver CS6] automates creation of media queries and it introduced Fluid Grid layout (see <<FIG11-11>>). It also allows you to quickly see how your design will look like on the tablet or phone (you can pick screen size too) with a click on the corresponding status bar button.

[[FIG11-11]]
.Creating a Fluid Grid Layout in Dreamweaver
image::images/ewdv_1013.png[]


TIP: Adobe's Creative Cloud includes a tool called https://creative.adobe.com/products/reflow[Edge Reflow], which will help designers in creation of responsive Web pages.

Web designers use different approaches in styling with fluid grids. When you design a new page with Dreamweaver's Fluid Grid Layout it suggests you to allocate different number of columns for desktop, tablet and mobile, for example, its default offer is to allocate 12 columns for the desktops, 8 for the tablets, and 5 for phones, which is perfectly solid approach. But our Web designer Jerry prefers using 12 columns for all screen sizes playing with the width percentages for different layouts - you'll see how he does it in the project Responsive Donation Section later in this chapter.  

Now imagine that you'll overlay the entire window with an invisible grid containing twelve equally sized columns. In this case each column will occupy 8.333% of the total width. Now, if you'd need to allocate to some HTML component about 40% of the total width, you could do this by allocating five grid columns (8.333% * 5 = 41.665%). Accordingly, your CSS file can contain 12 classes that you can use in your page:

[source, html]
----
.one-column {
	width: 8.333%;
}

.two-column {
	width: 16.666%;
}

.three-column {
	width: 24.999%;
}

.four-column {
	width: 33.332%;
}

.five-column {
	width: 41.665%;
}

.six-column {
	width: 49.998%;
}

.seven-column {
	width: 58.331%;
}

.eight-column {
	width: 66.664%;
}

.nine-column {
	width: 74.997%;
}

.ten-column {
	width: 83.33%;
}

.eleven-column {
	width: 91.663%;
}

.twelve-column {
	width: 100%;
	float: left;
}
----

Now let's see the fluid grid in action. Run the  project Responsive Fluid Grid and you'll see the Web page that looks similar to <<FIG11-12>>. This example changes the grid layout if the viewport width falls under one of the following width breakpoints: 768px, 640px, and 480px. In this context the term _breakpoints_ here has nothing to do with debugging - we just want the content of the Web page to be rearranged when the width of the viewport passes one of these values. 


[[FIG11-12]]
.Fluid Grid on the wide screen
image::images/ewdv_1014.png[]
 
If you'll start lowering the width of the browser's window, you'll see how the grid cells start squeezing, but the layout remains the same until the page size will become lower than one of the predefined breakpoints. Then another media query kicks in and the layout changes. For example, <<FIG11-13>> shows the fragment of the Web page when the width of the browser's window goes below 640px. The 12-, 6-, and 4-cell grids show all the cells vertically one under another. Only the 480px grids still have enough room to display their cells horizontally. But if you keep squeezing the window, all the grids will display their content in one column as long as the viewport width stays under 480px.

[[FIG11-13]]
.Fluid Grid on the viewport under 640px
image::images/ewdv_1015.png[]

The fragment of the index.html from the Responsive Fluid Grid project goes next. For brevity, we've removed some repetitive markup and marked such places with the comment "A fragment removed for brevity". This code fragment includes the 12-, 6-, and 4-column grids shown on top of <<FIG11-12>>.

[source, html]
----
<head>
	<meta charset="utf-8">
	<title>Responsive fluid grid</title>
	<meta name="description" content="Responsive fluid grid example">
	<meta name="viewport" content="width=device-width,initial-scale=1">

	<link rel="stylesheet" href="css/style.css">
</head>

<body>
  <div id="wrapper-container">

  	<h1 class="temp-heading">Responsive fluid grid example</h1>
  	<h4 class="temp-heading">Breakpoint-768: change float of HTML elements
  	                                  if viewport is 768px or smaller</h4>
  	<div class="row breakpoint-768">
  		<div class="one-column cell">
  				1
  		</div>
  		<div class="one-column cell">
  				2
  		</div>
  		<div class="one-column cell">
  				3
  		</div>
          
          <!--  A fragment removed for brevity -->

  		<div class="one-column cell last-cell" >
  				12
  		</div>
  	</div>

  	<h4 class="temp-heading">Breakpoint-768: change float of the 12-cell grid 
  	                                     if viewport is 768px or smaller</h4>

  	<div class="row breakpoint-768">
  		<div class="two-column cell">
  				1
  		</div>
  		<div class="two-column cell">
  				2
  		</div>
            
             <!--  A fragment removed for brevity -->

  		<div class="two-column cell">
  				6
  		</div>
  	</div>

  	<h4 class="temp-heading">Breakpoint-768: change float of the 6-cell grid
  	                                    if viewport is 768px or smaller</h4>

  	<div class="row breakpoint-640">
  		<div class="three-column cell">
  				1
  		</div>
  		<div class="three-column cell">
  				2
  		</div>
  		<div class="three-column cell">
  				3
  		</div>
  		<div class="three-column cell">
  				4
  		</div>
  	</div>
----

Note that some of the above HTML elements are styled with more than one class selector, for example `class="one-column cell"`. The entire content of the file styles.css from Responsive Fluid Grids project is shown next, and you can find the declarations of the class selectors `one-column` and `cell` there. 

[source, html]
----
* {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
	-webkit-box-sizing:border-box;
	-moz-box-sizing: border-box;
	box-sizing: border-box;
}

article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section {
	display: block;
}

ul li {
	list-style: none;
}

.row:before, .row:after, .clearfix:before, .clearfix:after {
	content: "";
	display: table;
}

.row:after, .clearfix:after {
	clear: both;
}

/* Start of fluid grid styles */

.row {                          //  <1>
	padding: 0 0 0 0.5em;
	background: #eee;
}

.breakpoint-480 .cell, .breakpoint-640 .cell, .breakpoint-768 .cell, 
                       .breakpoint-960 .cell, .no-breakpoint .cell { //<2>
	float: left;
	padding: 0 0.5em 0 0;
}

.one-column {                      
	width: 8.333%;    //  <3>
}

.two-column {
	width: 16.666%;   //  <4>
}

.three-column {
	width: 24.999%;   //   <5>
}

.four-column {
	width: 33.332%;
}

.five-column {
	width: 41.665%;
}

.six-column {
	width: 49.998%;
}

.seven-column {
	width: 58.331%;
}

.eight-column {
	width: 66.664%;
}

.nine-column {
	width: 74.997%;
}

.ten-column {
	width: 83.33%;
}

.eleven-column {
	width: 91.663%;
}

.twelve-column {
	width: 100%;
	float: left;
}

.right {
	float: right;
}

.row.nested {
	padding: 0;
	margin-right: -0.5em
}
----
<1> Styling grid rows, which  are containers for cells.

<2> Defining common class selectors (floating and padding) for the cells located in the viewports of any width. Please note the property `float: left;` - it'll change in the media queries section.

<3> Dividing 100% of the container's width by 12 columns results in allocating 8.333% of width per column. Each cell in the 12-column table in our HTML has the `one-column` class selector.

<4> Check the HTML for the 6-column grid - each cell is styled as `two-column` and will occupy 16.666% of the container's width.

<5> The HTML for the 4-column grid uses the `three-column` style for each cell that will use 24.999% of the container's width.

Note the section with media queries in this file (below is just another fragment of the same CSS file).  

[source, html]
----
/* --------------- Media queries -------------- */

@media only screen and (max-width: 768px) {
	.breakpoint-768 .cell {
		float: none;                         // <1>
		width: 100%;                         
		padding-bottom: 0.5em
	}
}

@media only screen and (max-width: 640px) {
	.breakpoint-640 .cell {                  // <2>
		float: none;
		width: 100%;
		padding-bottom: 0.5em
	}
}

@media only screen and (max-width: 480px) {
	.breakpoint-480 .cell {
		float: none;
		width: 100%;
		padding-bottom: 0.5em
	}
}

/*End of fluid grid styles*/

#wrapper-container {
	width: 95%;
	max-width: 1140px;
	margin: 0 auto;
}

/* --- .cell visualisation --- */
.cell {
	min-height: 50px;
	text-align:center;
	border-left: 1px solid #aaa;
	vertical-align: middle;
	line-height: 50px;
}
.cell .cell:first-child{ 
	border-left:none;
}
/* --- .cell visualisation end --- */

h1.temp-heading, h2.temp-heading, h4.temp-heading {
	font-size: 1.4em;
	margin: 1em 0;
	text-align: center
}
h4.temp-heading {
	font-size: 1.1em;
}

p.temp-project-description {
	margin: 2em 0;
}
----

<1> This media query turns off the floating (`float:none`) if the viewport is 768px or less. This will reallocate the cells vertically.
The `width:100%` forces the cell to occupy the entire width of the container as opposed to, say 8.333% in the 12-column grid.

<2> The media query for 640px won't kick in until the viewport width goes below 640px. If you'll resize the browser window to make it below 768px but larger than 640px, note that the 4-column grid (styled as `breakpoint-640`) has not changed its layout just yet. 


TIP: In some cases you may need to use a mix of fluid and fixed layouts, for example, you may need to include an image of a fixed size on your fluid Web page. In such cases you can use a fixed width on some of the elements, and if needed, consider using CSS tables (not to be confused with HTML tables). CSS tables http://caniuse.com/css-table[are supported] by all current browsers.

Spend some time analyzing the content of index.html and styles.css files from the project named Responsive Fluid Grid. Try to modify the values in CSS and see how your changes affect the behavior of the fluid grid. In the next section we'll apply these techniques to our Save The Child application.

==== Responsive CSS: The Good News

We were explaining how the fluid grid work under the hood, but  calculating percentages is not the most exciting job for sofrtare developers.  The good news is that there are several responsive frameworks that offer CSS, typography and some JavaScript to jump start the development of the UI of a Web application. They'll spare you for most of the mundane work with cascading style sheets. Here are some of them:

* Consider using Twitter's framework called http://twbs.github.io/bootstrap/[Bootstrap], which has lots of greatly styled http://twbs.github.io/bootstrap/components/[components] and also supports fluid grid system. 

* The http://foundation.zurb.com/[Foundation 4] framework promotes mobile first design and includes the flexible grid. 

* http://www.getskeleton.com/[The Skeleton] is a collection of CSS files, which includes a scalable grid.

* http://semantic-ui.com[Semantic-UI] is a collection of styled UI components, which includes http://semantic-ui.com/collections/grid.html[responsive grid] too.

TIP: People who work with CSS a lot use an authoring framework http://compass-style.org[Compass] with CSS extension http://sass-lang.com/[SASS] or a CSS pre-processor http://lesscss.org/[LESS], which are systems that compile to CSS allowing for code including variables for tracking and calculating such numbers as column with and more. You can now modularize your CSS as well as your code. In Chapter 12 we'll use a SASS theme that comes with Sencha Touch framework.   


=== Making Save The Child Responsive

First, run any of the previous versions of the Save The Child application to make sure it was not responsive. Just make the browser window narrower, and you won't see some of the page content on the right. We'll make the page responsive gradually - the first version will make the header responsive, then the donation section, and, finally the entire page will become fluid. Open in the Web browser the file index.html from the project named Responsive Header and you'll see a page similar to <<FIG11-14>>.  

[[FIG11-14]]
.Responsive Header (width 580px+)
image::images/ewdv_1016.png[]

Below is the fragment from index.html that displays the logo image and the header's menus.

[source, html]
----
<div id="wrapper-container">
  <header class="row breakpoint-640">
  	<h1 id="logo" class="four-column cell">
  	    <img src="assets/img/logo.png" alt="Save The Child logo"/></h1>
  	<nav class="eight-column cell">
  		<ul>
  			<li>
  				<a href="javascript:void(0)">Who We Are</a>
  			</li>
  			<li>
  				<a href="javascript:void(0)">What We Do</a>
  			</li>
  			<li>
  				<a href="javascript:void(0)">Where We Work</a>
  			</li>
  			<li>
  				<a href="javascript:void(0)">Way To Give</a>
  			</li>
  		</ul>
  	</nav>
----

Initially, this code uses the `four-column` style (`width: 33.332%;` of the container) for the logo and `eight-column` (`66.664%`) for the `<nav>` element. When the size of the viewport changes, the appropriate media query takes  effect. Note the `breakpoint-640` class selector in the `<header>` tag above. Jerry, our Web designer, decided that 640 pixels is not enough to display the logo and the four links from the `<nav>` section in one row. Besides, he wanted to fine tune the width of other elements too. This is how the media query for the 640px viewport looks like this:

[source, html]
----
@media only screen and (max-width: 640px) {
	.breakpoint-640 .cell {
		float: none;
		width: 100%;
		padding-bottom: 0.5em
	}

	header {
		margin-top: 1em;
	}
	#login {
		top: 1em;
	}
	#logo.four-column {
		width: 40%;
	}
	nav {
		width: 100%;
		margin-top: 0.8em
	}
	nav ul li {
		width: 24.5%;
		margin-left: 0.5%
	}
	nav li a {
		text-align: center;
		font-size: 0.6em;
	}
	#login-link-text {
		display: none;
	}
	a#login-submit {
		padding: 0.2em 0.5em
	}
	#login input {
		width: 9em;
	}
}
----

As you see, if the `cell` has to be styled inside `breakdown-640`, the float gets turned off (`float: none;`) and each of the navigation items has to take 100% of the container's width. The `logo`, `login`, and `nav` elements will change too. There is no exact science here - Jerry figured out all these values empirically.

Start slowly changing the width of the viewport, and you'll see how the layout changes. 
The styles.css of this project has media queries for different viewport sizes. For example, when the page width is below 580 pixels, but more than 480 pixels it'll look as in <<FIG11-15>>.

[[FIG11-15]]
.Responsive Header 2 (width between 480 and 580px )
image::images/ewdv_1017.png[]

When the width of the viewport shrinks below 480px, the header's content rearranges and looks as in <<FIG11-16>>. Once again, we are not tying the design to the specific device, but rather to a viewport width. The iPhone 4 will render this page using the layout shown at <<>FIG11-16>, but iPhone 5 will use the layout from <<FIG11-15>>. You can't go by a device type.

[[FIG11-16]]
.Responsive Header (viewport's width below 480px)
image::images/ewdv_1018.png[]

The next project to try is called Responsive Donation. This version make the donation section fluid. The donation section contains the Lorem Ipsum text and the form, which is revealed when the user clicks the button Donate. First, let's look at the HTML. The index.html contains the following fragment (some of the content that irrelevant for layout was removed for better readability):

[source, html]
----

<div id="main-content" role="main">
 <section id="main-top-section" class="row breakpoint-480">
   <div id="donation-address" class="seven-column cell">
   	<p class="donation-address">
   		Lorem ipsum dolor sit amet		</p>
   	<button class="donate-button" id="donate-button">
   		<span class="donate-button-header">Donate Now</span>
   	</button>

   </div>
   <div id="donate-form-container">
   	<h3>Make a donation today</h3>
   	<form name="_xclick" action="https://www.paypal.com/cgi-bin/webscr" 
   	                     method="post">

   	  <div class="row nested breakpoint-960">
   	  	<div class="six-column cell">
   	  	  <div class="row nested">
   	  	  <div id="donation-amount" class="five-column left">
   	  	    <label class="donation-heading">Donation amount</label>
   	  	    <input type="radio" name="amount" id="d10" value="10"/>
   	  	    <label for="d10">10</label>
   	  	  </div>
   	  	  <div id="donor-info" class="five-column left">
----

The donation section is located in the `main-top-section` of the page. Jerry wanted to keep the image of the boy visible for as long as possible on the narrower viewports. The top section of the Save The Child has two backgrounds: the flowers (bg-2.png) and the boy (child-1.png). This is how they are specified in the style.css:

[source, html]
----
#main-top-section {
	background: url(../img/child-1.png) no-repeat right bottom, 
	            url(../img/bg-2.png) no-repeat 20% bottom;
}
----

If the viewport is wide enough, both backgrounds will be shown. What's wide enough? Jerry figured it out after experimenting. The `seven-column` style prescribes to allocate more than a half (58.331%) of the viewport width for the `donation-address` section and `six-column` (49.998%) for the donation form.  For example <<FIG11-17>> shows how the donation section will look when the viewport width is 570px.

[[FIG11-17]]
.Responsive Donate Section: 570px
image::images/ewdv_1019.png[]

But when the width become less then 480px, there is no room for two background images, and only the flowers will remain on the page background. The media query for 480px viewport is shown next - note that the background in the main top section has only one image now: bg2.png. Floating is off to show the navigation menu vertically as in <<FIG11-18>>.

[source, html]
----
@media only screen and (max-width: 480px) {
	.breakpoint-480 .cell {
		float: none;
		width: 100%;
		padding-bottom: 0.5em
	}
	#logo {
		padding-bottom: 11em
	}
	nav ul li {
		float: none;
		width: 100%;
		margin-left: 0;
		margin-bottom: 0.5%;
	}
	#main-top-section {
		background: url(../img/bg-2.png) no-repeat 20% bottom;
	}
	.donate-button {
		width: 14em;
		margin-left: auto;
		margin-right: auto;
	}
	.donate-button-header {
		font-size: 1.1em;
	}
	.donate-2nd-line {
		font-size: 0.9em;
	}
	#donate-later-link {
		display: block;
		width: 11em;
		margin-left: auto;
		margin-right: auto;
	}
	#make-payment p {
		width: 100%;
	}
	#donation-amount.five-column {
		width: 50%
	}
	#donor-info.six-column {
		width: 50%
	}
	#donate-form-container select, input[type=text], input[type=email] {
		width: 90%;
	}
}
----

[[FIG11-18]]
.Responsive Donate Section under 480px
image::images/ewdv_1020.png[]

The project Responsive Final includes the charts, maps, and video. Each of these sections uses `four-column` style, which is defined in styles.css as 33.332% of the container's width. 

[source, html]
----
<section id="main-bottom-section" class="row breakpoint-768">

  <div id="charts-container" class="four-column cell">
  	<svg id="svg-container"  xmlns="http://www.w3.org/2000/svg">

  	</svg>
  	<h3>Donation Stats</h3>
  	<h5>Lorem ipsum dolor sit amet, consect.</h5>
  </div>
  <div id="map-container" class="four-column cell">
  	<div id="location-map"></div>
  	<div id="location-ui"></div>
  </div>
  <div id="video-container" class="four-column cell last">
  	<div id="video-wrapper">
  	  <video id="movie" controls="controls" 
  	         poster="assets/media/intro.jpg" preload="metadata">
  	  	<source src="assets/media/intro.mp4" type="video/mp4">
  	  	<source src="assets/media/intro.webm" type="video/webm">
  	  	<p>Sorry, your browser doesn't support the video element</p>
  	  </video>
  	</div>
  	<h3>Video header goes here</h3>
  	<h5><a href="javascript:void(0);">More video link</a></h5>
  </div>
</section>
----

The id of this section is still `main-bottom-section`, and it's shown at the bottom of the page on wide viewports. Now take another look at the image <<FIG11-9>>. Jerry wants to display these three sections at the right hand side for tablets in the portrait mode, and it's shown on <<FIG11-19>>. 

[[FIG11-19]]
.The Portrait Mode on Tablets 
image::images/ewdv_1021.png[]

The relevant code from the style.css is shown below.The top and bottom sections get about a half of the width each, and the floating is turned off so the browser would allocate charts, maps, and video vertically.

[source, html]
----
@media only screen and (max-width: 768px) {
	.breakpoint-768 .cell {
		float: none;
		width: 100%;
		padding-bottom: 0.5em;
	}

	#main-bottom-section, #main-top-section {
		width: 49%;
	}
----

NOTE: We've explained the use of media queries for applying different styles to the UI based on screen resolutions. But there is a twist to it. What device comes to mind if you hear about the screen with the resolution of 1920x1080 pixels? Most likely you got it wrong unless your answer was the smartphone Galaxy S4 or Sony Xperia Z. The resolution is high, but the screen size is 5 inches. What media query are you going to apply if the user has such a device? Even with such high resolution you'd rather not apply the desktop's CSS to such a mobile device. The CSS media query http://bjango.com/articles/min-device-pixel-ratio/[_device-pixel-ratio_] may help you in telling apart high-resolution small devices from desktops.


==== Fluid Media

If you responsive Web page contains images or videos, you want to make them fluid too - they should react to the current size of the containers they are in. Our page has a chart image and a video - both of them are made flexible, but we use different techniques.

If you'll keep narrowing the viewport, the project Responsive Final will show the page with the layout similar to <<FIG11-10>>. While reading the code of this project, visit the main.js file. There is some work done in the JavaScript too, which listens to the resize event for the charts container. 

[source, javascript]
----
window.addEventListener("resize", windowResizeHandler);
function windowResizeHandler() {
	drawPieChart(document.getElementById('svg-container'), 
	                 donorsDataCache, labelsDataCache);
}
----

Whenever the size changes, it invokes the function `drawPieChart()` that recalculates the width of the SVG container (it uses the `clientWidth` property of the `HTMLElement` ) and re-draws the chart accordingly.


TIP: Consider storing images in the https://developers.google.com/speed/webp/[WebP format], which is a lossless format, and WebP images are about 25% less in sizethan PNG or JPEG images. Your application needs to check first if the user's Web browser support WebP format, otherwise images in more traditional formats should be rendered. The other choice is to use http://thumborize.me/[Tumbor imaging service] that can automatically serve WebP images to the browsers that support this format. 

The video is flexible too, and it's done a lot simpler. We do not specify the fixed size of the video, but use a CSS property `width` instructing the browser to allocate the 100% of the available container's width.The height of the video must be  be automatically calculated to keep the proportional size. 

[source, html]
----
video {
	width: 100% !important;
	height: auto !important;
}
----

The `!important` part disables regular cascading rules and ensures that these values will be applied overriding more specific width or height declarations, if any. If you prefer not always use the entire width of the container for the video, you can use the `max-width: 100%;`, which will display the video that fits in the container at its original size. If a video is larger than the container, the browser will resize it to fit inside the container. 

While the landing Web page of your application simply includes links to the required images, the rest of the images should be loaded from the server by making AJAX requests with passing parameter regarding the viewport size. This way the server's software can either resize images dynamically and include them as base-64 encoded strings or use pre-created properly sized images depending on the viewport dimensions.

TIP: While using base-64 encoding increases the total size of the image in bytes, it allows you to group together multiple images to minimize the number of network calls the browser needs to make to retrieve these images separately. The other way to combine multiple images into one is CSS sprites.

Regardless of what the width and height of the image is, use tools to reduce image sizes in bytes. Some of such tools are http://tinypng.org/[TinyPNG] or http://www.smushit.com/ysmush.it/[Smush.it]. If you use _lossy_ tools, some of the image data will be lost during compression, but in many cases the difference between the original and compressed image is invisible. 

TIP: http://www.sencha.com/learn/how-to-use-src-sencha-io/[Sencha.io SRC] is a proxy server that allows you to dynamically resize images for various mobile screen sizes.

Besides making images responsive, keep in mind that some people have mobile devices with high resolution retina displays. The problem is that to make an image look good on such displays its size has to be large, which increases its loading time. There is no common recipe for doing the image size optimization properly - plan to spend an extra time just to preparing the images for your application. 

There is a living W3C document titled http://picture.responsiveimages.org/[An HTML extension for adaptive images] that will provide developers with a means to declare multiple sources for an image. The proposed  HTML element `<picture>` will allow to specify different images for different media (see http://responsiveimages.org/demos/[demos]), for example:

[source, html]
----
<picture width="500" height="500">
   <source media="(min-width: 45em)" src="large.jpg">
   <source media="(min-width: 18em)" src="med.jpg">
   <source src="small.jpg">
   <img src="small.jpg" alt="">
</picture>
----

Another technique is to have a CDN that caches and serves images of different sizes for different user agents. The very first time when a request is made from a device with an unknown user engine, this first  "unlucky" user will get an image with a low resolution, and then the application makes an AJAX call passing the exact screen parameters for this device. The CDN server resizes the original high-resolution image for this particular user agent, and caches it, so any other users having the same device will get a perfectly-sized image from the get go.   

TIP: https://github.com/BBC-News/Imager.js[Imager.js] is an alternative solution to the issue of how to handle responsive image loading, created by developers at BBC News. Imager loages the most suitable sized image and does it once.


=== Summary 

Responsive Web design is not a silver bullet that allows using a single code base for all desktop and mobile versions of your HTML5 Web application. RWD can be the right approach for developing Web sites that mainly publish information. It's not likely that you can create a complex single-code-base Web application that works well on Android, iPhone, and desktop browsers. 
 
Responsive design may result in unnecessary CSS loaded to the user's device. This consideration is especially important for mobile devices operating on 3G or slower networks (unless you'll find a way to lazy load them). 

Responsive design can still can be a practical business solution when the form factor is relatively low (which enterprise can mandate), e.g. if your target group of user operate specific models of iOS and Android devices. 

If you'll take any JavaScript framework that works on both desktop and mobile devices, you'll get two sets of controls and will have to maintain two different source code repositories. Not using mobile JavaScript frameworks limits the number of user-friendly UI controls. Besides, frameworks spare you from dealing with browsers' incompatibilities.

In this chapter you've seen how the Save The Child application  was built with responsive design principles. We have several areas (`<div>'s`) and one of them included a donation form (we could have added the responsive `<div>` with the online auction too). On the wide screen we displayed three  of these `<div>'s`  horizontally and two underneath, on the narrow screen each of these sections could scaled down and displayed one under another. 

But using responsive design for styling the application that must run on tablets or mobile devices will require Jerry-the-designer to work in tandem with the User Experience specialist so that UI will have larger controls and fonts while  minimizing the need of manual data entry. And don't forget that the half of a mobile screen could be covered by a virtual keyboard, and if you ignore this, the user will look at your application's UI  via a keyhole and even our fluid `<div>'s` may not fit. 

In the next two chapters we'll be working on yet another version of the Save The Child application. First, we'll use the jQuery Mobile framework and then - Sencha Touch.